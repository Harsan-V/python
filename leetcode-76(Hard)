#brute force
from collections import Counter

class Solution(object):
    def minWindow(self, s, t):
        if not s or not t:
            return ""

        need = Counter(t)
        min_len = float("inf")
        result = ""

        for i in range(len(s)):
            for j in range(i, len(s)):
                sub = s[i:j+1]
                freq = Counter(sub)

                valid = True
                for ch in need:
                    if freq[ch] < need[ch]:
                        valid = False
                        break

                if valid and len(sub) < min_len:
                    min_len = len(sub)
                    result = sub

        return result

# Optimal Solution

from collections import Counter

class Solution(object):
    def minWindow(self, s, t):
        if not t or not s:
            return ""

        need = Counter(t)
        window = {}

        have = 0
        need_count = len(need)

        left = 0
        res = [-1, -1]
        res_len = float("inf")

        for right in range(len(s)):
            c = s[right]
            window[c] = window.get(c, 0) + 1

            if c in need and window[c] == need[c]:
                have += 1

            while have == need_count:
                if (right - left + 1) < res_len:
                    res = [left, right]
                    res_len = right - left + 1

                window[s[left]] -= 1
                if s[left] in need and window[s[left]] < need[s[left]]:
                    have -= 1

                left += 1

        l, r = res
        return s[l:r+1] if res_len != float("inf") else ""
